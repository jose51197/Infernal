--- drivers/staging/zram/zram_drv.c
+++ drivers/staging/zram/zram_drv.c
@@ -32,16 +32,12 @@
 #include <linux/lzo.h>
 #include <linux/string.h>
 #include <linux/vmalloc.h>
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-#include <linux/swap.h>
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
-
 
 #include "zram_drv.h"
 
 /* Globals */
 static int zram_major;
-struct zram *zram_devices;
+struct zram *devices;
 
 /* Module params (documentation at end) */
 unsigned int num_devices;
@@ -137,22 +133,6 @@
 	zram->disksize &= PAGE_MASK;
 }
 
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-/*
- * Swap header (1st page of swap device) contains information
- * about a swap file/partition. Prepare such a header for the
- * given ramzswap device so that swapon can identify it as a
- * swap partition.
- */
-static void setup_swap_header(struct zram *zram, union swap_header *s)
-{
-	s->info.version = 1;
-	s->info.last_page = (zram->disksize >> PAGE_SHIFT) - 1;
-	s->info.nr_badpages = 0;
-	memcpy(s->magic.magic, "SWAPSPACE2", 10);
-}
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
-
 static void zram_free_page(struct zram *zram, size_t index)
 {
 	u32 clen;
@@ -521,10 +501,6 @@
 {
 	int ret;
 	size_t num_pages;
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-	struct page *page;
-	union swap_header *swap_header;
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
 
 	mutex_lock(&zram->init_lock);
 
@@ -559,19 +535,6 @@
 		goto fail;
 	}
 
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-	page = alloc_page(__GFP_ZERO);
-	if (!page) {
-		pr_err("Error allocating swap header page\n");
-		ret = -ENOMEM;
-		goto fail;
-	}
-	zram->table[0].page = page;
-	zram_set_flag(zram, 0, ZRAM_UNCOMPRESSED);
-	swap_header = kmap(page);
-	setup_swap_header(zram, swap_header);
-	kunmap(page);
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
 	set_capacity(zram->disk, zram->disksize >> SECTOR_SHIFT);
 
 	/* zram devices sort of resembles non-rotational disks */
@@ -715,14 +678,14 @@
 
 	/* Allocate the device array and initialize each one */
 	pr_info("Creating %u devices ...\n", num_devices);
-	zram_devices = kzalloc(num_devices * sizeof(struct zram), GFP_KERNEL);
-	if (!zram_devices) {
+	devices = kzalloc(num_devices * sizeof(struct zram), GFP_KERNEL);
+	if (!devices) {
 		ret = -ENOMEM;
 		goto unregister;
 	}
 
 	for (dev_id = 0; dev_id < num_devices; dev_id++) {
-		ret = create_device(&zram_devices[dev_id], dev_id);
+		ret = create_device(&devices[dev_id], dev_id);
 		if (ret)
 			goto free_devices;
 	}
@@ -731,8 +694,8 @@
 
 free_devices:
 	while (dev_id)
-		destroy_device(&zram_devices[--dev_id]);
-	kfree(zram_devices);
+		destroy_device(&devices[--dev_id]);
+	kfree(devices);
 unregister:
 	unregister_blkdev(zram_major, "zram");
 out:
@@ -745,7 +708,7 @@
 	struct zram *zram;
 
 	for (i = 0; i < num_devices; i++) {
-		zram = &zram_devices[i];
+		zram = &devices[i];
 
 		destroy_device(zram);
 		if (zram->init_done)
@@ -754,7 +717,7 @@
 
 	unregister_blkdev(zram_major, "zram");
 
-	kfree(zram_devices);
+	kfree(devices);
 	pr_debug("Cleanup done!\n");
 }
 
