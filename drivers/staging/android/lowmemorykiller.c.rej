--- drivers/staging/android/lowmemorykiller.c
+++ drivers/staging/android/lowmemorykiller.c
@@ -36,12 +36,6 @@
 #include <linux/sched.h>
 #include <linux/rcupdate.h>
 #include <linux/notifier.h>
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-#include <linux/swap.h>
-#include <linux/device.h>
-#include <linux/err.h>
-#include <linux/mm_inline.h>
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
 #include <linux/memory.h>
 #include <linux/memory_hotplug.h>
 
@@ -60,82 +54,6 @@
 	16 * 1024,	/* 64MB */
 };
 static int lowmem_minfree_size = 4;
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-static struct class *lmk_class;
-static struct device *lmk_dev;
-static int lmk_kill_pid = 0;
-static int lmk_kill_ok = 0;
-#define MM_SWAPON 0xaa
-
-extern atomic_t optimize_comp_on;
-
-extern int isolate_lru_page(struct page *page);
-extern void putback_lru_page(struct page *page);
-extern unsigned int zone_id_shrink_pagelist(struct zone *zone_id,struct list_head *page_list);
-
-#define lru_to_page(_head) (list_entry((_head)->prev, struct page, lru))
-
-#define SWAP_PROCESS_DEBUG_LOG 1
-/* free RAM 8M(6250 pages) */
-#define CHECK_FREE_MEMORY 2048
-/* free swap (10240 pages) */
-#define CHECK_FREE_SWAPSPACE  10240
-
-struct scan_control {
-	/* Incremented by the number of inactive pages that were scanned */
-	unsigned long nr_scanned;
-
-	/* Number of pages freed so far during a call to shrink_zones() */
-	unsigned long nr_reclaimed;
-
-	/* How many pages shrink_list() should reclaim */
-	unsigned long nr_to_reclaim;
-
-	unsigned long hibernation_mode;
-
-	/* This context's GFP mask */
-	gfp_t gfp_mask;
-
-	int may_writepage;
-
-	/* Can mapped pages be reclaimed? */
-	int may_unmap;
-
-	/* Can pages be swapped as part of reclaim? */
-	int may_swap;
-
-	int swappiness;
-
-	int order;
-
-	/*
-	 * Intend to reclaim enough contenious memory rather than to reclaim
-	 * enough amount memory. I.e, it's the mode for high order allocation.
-	 */
-	bool lumpy_reclaim_mode;
-
-	/* Which cgroup do we reclaim from */
-	struct mem_cgroup *mem_cgroup;
-
-	/*
-	 * Nodemask of nodes allowed by the caller. If NULL, all nodes
-	 * are scanned.
-	 */
-	nodemask_t	*nodemask;
-};
-
-enum pageout_io {
-	PAGEOUT_IO_ASYNC,
-	PAGEOUT_IO_SYNC,
-};
-
-extern unsigned long shrink_page_list(struct list_head *page_list,
-				      struct zone *zone,
-				      struct scan_control *sc);
-extern unsigned long clear_active_flags(struct list_head *page_list,
-					unsigned int *count);
-
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
 
 static unsigned int offlining;
 static struct task_struct *lowmem_deathpending;
@@ -317,256 +235,6 @@
 	.seeks = DEFAULT_SEEKS * 16
 };
 
-#ifdef CONFIG_ZRAM_FOR_ANDROID
-/*
- * zone_id_shrink_pagelist() clear page flags,
- * update the memory zone status, and swap pagelist
- */
-
-static unsigned int shrink_pages(struct mm_struct *mm, struct zone **zone_id_0,
-				 struct list_head *zone0_page_list,
-				 struct zone **zone_id_1,
-				 struct list_head *zone1_page_list,
-				 unsigned int num_to_scan)
-{
-	unsigned long addr;
-	unsigned int isolate_pages_countter = 0;
-
-	struct vm_area_struct *vma = mm->mmap;
-	while (vma != NULL) {
-
-		for (addr = vma->vm_start; addr < vma->vm_end;
-		     addr += PAGE_SIZE) {
-			struct page *page;
-			/*get the page address from virtual memory address */
-			page = follow_page(vma, addr, FOLL_GET);
-
-			if (page && !IS_ERR(page)) {
-
-				put_page(page);
-				/* only moveable, anonymous and not dirty pages can be swapped  */
-				if ((!PageUnevictable(page))
-				    && (!PageDirty(page)) && ((PageAnon(page)))
-				    && (0 == page_is_file_cache(page))) {
-					switch (page_zone_id(page)) {
-					case 0:
-						if (!isolate_lru_page(page)) {
-							/* isolate page from LRU and add to temp list  */
-							*zone_id_0 =
-							    page_zone(page);
-							/*create new page list, it will be used in shrink_page_list */
-							spin_lock_irq(&(*zone_id_0)->lru_lock);
-							list_add_tail(&page->lru, zone0_page_list);
-							spin_unlock_irq(&(*zone_id_0)->lru_lock);
-							isolate_pages_countter++;
-						}
-						break;
-					case 1:
-						if (!isolate_lru_page(page)) {
-							/* isolate page from LRU and add to temp list  */
-							*zone_id_1 =
-							    page_zone(page);
-							/*create new page list, it will be used in shrink_page_list */
-							spin_lock_irq(&(*zone_id_1)->lru_lock);
-							list_add_tail(&page->lru, zone1_page_list);
-							spin_unlock_irq(&(*zone_id_1)->lru_lock);
-							isolate_pages_countter++;
-						}
-						break;
-					default:
-						break;
-					}
-				}
-			}
-
-			if (isolate_pages_countter >= num_to_scan) {
-				return isolate_pages_countter;
-			}
-		}
-
-		vma = vma->vm_next;
-	}
-
-	return isolate_pages_countter;
-}
-
-/*
- * swap_application_pages() will search the
- * pages which can be swapped, then call
- * zone_id_shrink_pagelist to update zone
- * status
- */
-static unsigned int swap_pages(struct zone *zone_id_0,
-			       struct list_head *zone0_page_list,
-			       struct zone *zone_id_1,
-			       struct list_head *zone1_page_list)
-{
-	unsigned int pages_counter = 0;
-
-	/*if the page list is not empty, call zone_id_shrink_pagelist to update zone status */
-	if ((zone_id_0) && (!list_empty(zone0_page_list))) {
-		pages_counter +=
-		    zone_id_shrink_pagelist(zone_id_0, zone0_page_list);
-	}
-	if ((zone_id_1) && (!list_empty(zone1_page_list))) {
-		pages_counter +=
-		    zone_id_shrink_pagelist(zone_id_1, zone1_page_list);
-	}
-	return pages_counter;
-}
-
-static ssize_t lmk_state_show(struct device *dev,
-			      struct device_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%d,%d\n", lmk_kill_pid, lmk_kill_ok);
-}
-
-/*
- * lmk_state_store() will called by framework,
- * the framework will send the pid of process that need to be swapped
- */
-static ssize_t lmk_state_store(struct device *dev,
-			       struct device_attribute *attr,
-			       const char *buf, size_t size)
-{
-	sscanf(buf, "%d,%d", &lmk_kill_pid, &lmk_kill_ok);
-
-	/* if the screen on, the optimized compcache will stop */
-	if (atomic_read(&optimize_comp_on) != 1)
-		return size;
-
-	if (lmk_kill_ok == 1) {
-		struct task_struct *p;
-		struct task_struct *selected = NULL;
-		struct sysinfo ramzswap_info = { 0 };
-
-		/*
-		 * check the free RAM and swap area,
-		 * stop the optimized compcache in cpu idle case;
-		 * leave some swap area for using in low memory case
-		 */
-		si_swapinfo(&ramzswap_info);
-		si_meminfo(&ramzswap_info);
-
-		if ((ramzswap_info.freeswap < CHECK_FREE_SWAPSPACE) ||
-		    (ramzswap_info.freeram < CHECK_FREE_MEMORY)) {
-			lmk_kill_ok = 0;
-			return size;
-		}
-
-		read_lock(&tasklist_lock);
-		for_each_process(p) {
-			if ((p->pid == lmk_kill_pid) &&
-			    (__task_cred(p)->uid > 10000)) {
-				task_lock(p);
-				selected = p;
-				if (!selected->mm || !selected->signal) {
-					task_unlock(p);
-					selected = NULL;
-					pr_info("idletime compcache: process is being killed\n");
-					break;
-				}
-				else {
-#if SWAP_PROCESS_DEBUG_LOG > 0
-					pr_info("idletime compcache: swap process pid %d, name %s, task_size %ld\n",
-						p->pid, p->comm, get_mm_rss(p->mm));
-#endif
-				}
-				break;
-			}
-		}
-		read_unlock(&tasklist_lock);
-
-		if (selected) {
-			struct zone *zone0 = NULL, *zone1 = NULL;
-			LIST_HEAD(zone0_page_list);
-			LIST_HEAD(zone1_page_list);
-			int pages_tofree = 0, pages_freed = 0;
-
-			pages_tofree =
-			    shrink_pages(selected->mm, &zone0, &zone0_page_list,
-					 &zone1, &zone1_page_list, 0x7FFFFFFF);
-			task_unlock(selected);
-			pages_freed =
-			    swap_pages(zone0, &zone0_page_list, zone1,
-				       &zone1_page_list);
-			lmk_kill_ok = 0;
-
-		}
-	}
-
-	return size;
-}
-
-static DEVICE_ATTR(lmk_state, 0664, lmk_state_show, lmk_state_store);
-
-/*
- *  swap_inactive_pagelist() will be called in low memory case,
- *  swap SWAP_CLUSTER_MAX pages to swap space
- */
-int swap_inactive_pagelist(unsigned int page_swap_cluster)
-{
-	struct task_struct *p, *selected = NULL;
-	int tasksize;
-	int hidden_min_oom_adj = 9;
-	int pages_counter = 0;
-
-	read_lock(&tasklist_lock);
-	for_each_process(p) {
-		struct mm_struct *mm;
-		struct signal_struct *sig;
-		int oom_adj;
-
-		task_lock(p);
-		mm = p->mm;
-		sig = p->signal;
-		if (!mm || !sig) {
-			task_unlock(p);
-			continue;
-		}
-
-		tasksize = get_mm_rss(mm);
-
-		if (tasksize <= 0) {
-			task_unlock(p);
-			continue;
-		}
-
-		oom_adj = sig->oom_adj;
-		if (oom_adj >= hidden_min_oom_adj) {
-			selected = p;
-#if SWAP_PROCESS_DEBUG_LOG > 0
-			printk
-			    ("runtime compcache: swap process pid %d, name %s, oom %d\n",
-			     p->pid, p->comm, oom_adj);
-#endif
-			break;
-		}
-		task_unlock(p);
-	}
-	read_unlock(&tasklist_lock);
-
-	if (selected) {
-		struct zone *zone0 = NULL, *zone1 = NULL;
-		LIST_HEAD(zone0_page_list);
-		LIST_HEAD(zone1_page_list);
-
-		shrink_pages(selected->mm, &zone0, &zone0_page_list, &zone1,
-			     &zone1_page_list, 32);
-		task_unlock(selected);
-		pages_counter =
-		    swap_pages(zone0, &zone0_page_list, zone1,
-			       &zone1_page_list);
-		printk("pagefreed = %d\n", pages_counter);
-	}
-
-	return pages_counter;
-}
-EXPORT_SYMBOL(swap_inactive_pagelist);
-
-
-#endif /* CONFIG_ZRAM_FOR_ANDROID */
-
 static int __init lowmem_init(void)
 {
 	task_free_register(&task_nb);
